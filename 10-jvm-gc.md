# 10. JVM内存与GC

## 知识点详解

### 10.1 JVM内存结构
堆用于存放对象实例，通常分为年轻代和老年代；栈保存线程栈帧与局部变量；方法区（Metaspace）存放类元数据与常量；直接内存用于NIO缓冲区，不受堆限制但受系统内存限制。不同区域的溢出和诊断手段不同。

### 10.2 GC算法
标记清除会产生内存碎片；复制算法适合存活率低的区域；标记整理在回收后压缩内存，减少碎片。不同算法组合成不同收集器的实现策略。

### 10.3 常见收集器
Serial单线程、适合小堆；Parallel重吞吐、停顿较长；CMS追求低停顿但容易产生碎片并可能触发Full GC；G1基于Region并可预测停顿时间，适合大堆；ZGC追求极低停顿，适用于超大堆与低延迟场景。

### 10.4 GC日志理解
Young GC通常因Eden耗尽触发，Full GC可能由老年代或元空间不足触发。关注停顿时间、GC频率、晋升速度与分配速率。通过日志可以判断是否存在过早晋升、晋升失败或频繁Full GC。

### 10.5 内存泄漏与内存溢出
内存泄漏是对象不再使用却仍被引用，最终可能导致OOM；内存溢出是分配失败。诊断通常通过heap dump、对象占用分析、引用链追踪来定位泄漏根因。

## 面试点与参考回答

### Q1 G1适用场景与特点
G1适合大堆、低停顿需求的场景，支持并行与并发回收，通过Region化管理与停顿预测来控制最大暂停时间。

### Q2 Full GC常见触发原因
老年代空间不足、元空间不足、显式System.gc、担保机制失败或碎片严重都会触发Full GC。频繁Full GC意味着分配过快或回收效率不足。

### Q3 常见OOM类型与排查
常见包括 `Java heap space`、`Metaspace`、`GC overhead limit exceeded`、`Direct buffer memory`、`unable to create new native thread`。排查需要结合heap dump、GC日志和系统资源指标。

## 掌握评估

### 自测1 能读GC日志并判断问题
给出一段GC日志，判断是Young GC过频还是Full GC过频，并说明可能原因。

### 自测2 能给出合理的GC参数建议
根据业务目标（吞吐或延迟），选择合适收集器并给出关键参数，如堆大小、停顿目标或并行线程数。
