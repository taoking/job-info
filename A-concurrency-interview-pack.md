# A. 并发面试题示例与参考答案

## 面试题示例与参考答案

### Q1 解释 volatile 的语义，为什么不能保证复合操作原子性
volatile保证可见性和有序性，写入后会刷新到主内存并对后续读建立happens-before关系。但它不保证复合操作原子性，例如 `i++` 包含读、加、写三步，两个线程可能交错执行导致丢失更新。若需要原子性，应使用锁或原子类。

### Q2 synchronized 锁升级过程及其触发条件是什么
synchronized会在无竞争时保持轻量状态，竞争出现时逐步升级以减少无竞争开销并在激烈竞争下保证正确性。触发条件包括多个线程争用同一锁、等待队列增长或自旋失败。不同JDK版本对偏向锁策略有所差异，但核心原则是“竞争越激烈，锁越重”。

### Q3 ReentrantLock 和 synchronized 的区别与使用场景
ReentrantLock提供可中断、可超时、公平锁以及多Condition等能力，适合需要精细控制的场景；synchronized语法简单、由JVM管理释放，适合简单互斥场景。两者性能差异与竞争程度有关，选择应以可维护性和需求为主。

### Q4 解释 happens-before 规则，并举出2个实际例子
happens-before是可见性与有序性的约束规则。例子一：对同一锁的unlock happens-before 之后的lock；例子二：对同一volatile变量的写 happens-before 后续读。线程start之前的操作对新线程可见，线程join之后可见新线程的操作。

### Q5 线程池参数如何设置？IO密集与CPU密集的差异
CPU密集型任务线程数通常接近核心数，避免过多上下文切换；IO密集型任务可以适当放大线程数以覆盖等待时间。队列容量要结合吞吐目标、延迟要求与可接受的排队上限，优先选择有界队列并配合拒绝策略和监控。

### Q6 线程池队列堆积如何排查
先看队列长度、活跃线程数、任务耗时分位数与拒绝次数，判断是否是上游突发或下游变慢。再定位是否有任务阻塞、锁竞争或外部依赖超时。必要时通过线程栈和指标确认瓶颈点。

### Q7 ConcurrentHashMap 在 JDK8 中的实现关键点
JDK8使用CAS + synchronized实现桶级别锁，减少全局锁竞争；链表过长时树化为红黑树提升查询效率；扩容使用sizeCtl控制并行迁移，支持多线程协作搬迁桶。

### Q8 CAS 的 ABA 问题是什么？如何解决
ABA指某值从A变为B又变回A，CAS无法感知变化。解决方案包括加入版本号或时间戳，如 AtomicStampedReference，或使用不可变对象与乐观锁版本字段。

### Q9 解释 ThreadLocal 的原理与常见内存泄漏场景
ThreadLocal在每个线程内维护一个ThreadLocalMap，key为弱引用、value为强引用。线程池线程生命周期长，若不调用remove，value会长期存在，导致内存泄漏。正确做法是使用后及时remove或使用try-finally清理。

### Q10 如何定位死锁？有哪些预防策略
定位死锁可通过jstack或jcmd获取线程dump，检查相互等待的锁。预防策略包括保持一致的锁顺序、减少锁嵌套、使用tryLock或超时锁以及避免长时间持锁操作。

## 标准答题模板解读

### 步骤1 定义与目标
先给出概念或问题定义，说明它解决的核心目标，例如“volatile解决可见性与有序性问题”。

### 步骤2 原理与机制
描述底层机制或执行流程，强调关键步骤和JMM规则，使回答具备技术深度。

### 步骤3 关键细节
补充易错点、边界条件或实现细节，比如“volatile不保证原子性”。

### 步骤4 场景与取舍
给出适用场景与替代方案，说明为什么不在某些场景使用它。

### 步骤5 风险与排查
列出常见问题与排查手段，体现工程化能力与实战经验。

## 自测评分表解读

### 概念准确性
1分表现为只背概念且易混淆；3分能说明核心定义但细节模糊；5分能精准定义并结合例子说明。

### 机制理解
1分几乎不了解底层过程；3分能描述部分步骤；5分能把完整流程串起来并指出关键瓶颈。

### 场景取舍
1分无法给出场景；3分能说出常见场景；5分能根据性能与安全取舍并说明原因。

### 排查能力
1分只会重启；3分会用单个工具；5分能形成完整排障链路并验证假设。

### 表达结构
1分零散无结构；3分有结构但不连贯；5分结构清晰、可复述并可扩展。

## 资深级参考答案要点与追问

### 1) volatile语义与限制
要点包括可见性、有序性、建立写-读happens-before、不保证复合操作原子性。常见场景是状态标记与DCL。追问通常涉及内存屏障与为什么不能替代锁，需要结合JMM解释。

### 2) synchronized与锁升级
要点是对象监视器、monitorenter/monitorexit、锁状态随竞争升级、适合短临界区。追问可能涉及锁粗化、锁消除与竞争下性能瓶颈。

### 3) ReentrantLock对比synchronized
要点是可中断、可定时、公平策略、多Condition与显式释放。追问集中在公平锁的代价与Condition与wait/notify差异。

### 4) happens-before规则
要点是程序次序、锁规则、volatile规则、线程启动/终止规则与传递性。追问常涉及DCL必须volatile的原因。

### 5) 线程池参数设置
要点是核心线程数、最大线程数、队列与拒绝策略对吞吐与延迟的影响，IO与CPU密集差异，监控与压测。追问常在“耗尽时如何降级与避免OOM”。

### 6) ConcurrentHashMap（JDK8）
要点是CAS + synchronized桶级锁、树化提升性能、sizeCtl与transfer并行扩容。追问常问为何树化而不是扩容。

### 7) CAS与ABA
要点是乐观并发、失败重试、ABA问题与版本号解决方案。追问常问LongAdder为何在高竞争下更好。

### 8) ThreadLocal内存泄漏
要点是弱引用key、强引用value、线程池线程长期存活导致value无法回收，使用后remove。追问常问线程池场景下的最佳实践。

### 9) 死锁定位
要点是线程dump识别互相等待锁，预防用锁顺序、减少嵌套、超时锁。追问可讨论线上无侵入dump的方式。

## 资深级自测标准

### 标准1
能判断瓶颈是CPU、锁竞争还是IO，并给出验证依据。

### 标准2
能提出至少两种并发控制方案并比较取舍。

### 标准3
能结合队列长度、活跃线程、拒绝次数等指标判断风险。
