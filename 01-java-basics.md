# 1. Java语言基础与面向对象

## 知识点详解

### 1.1 值类型与引用类型
Java只有“值传递”。基本类型变量里直接存值，对象变量里存的是对象引用的拷贝。调用方法时，参数会被拷贝一份传入，因此方法内部重新给参数赋值不会影响外部变量，但如果通过引用修改对象内部状态，外部可以观察到变化。理解这一点可以避免把“引用传递”当成Java语义的误解。

示例可以用两个层面理解：第一层是“引用变量本身”的拷贝；第二层是“引用指向的对象”是否被修改。前者不会影响调用方，后者会。这个区别决定了你在方法里是应该返回新对象，还是修改传入对象。

```java
static void change(int x, StringBuilder sb) {
    x = 2;                 // 仅改变了局部拷贝
    sb.append("!");       // 修改了同一个对象
}

int a = 1;
StringBuilder b = new StringBuilder("hi");
change(a, b);
// a 仍为 1，b 变为 "hi!"
```

### 1.2 自动装箱与拆箱
自动装箱/拆箱是编译期语法糖，把基本类型与包装类型在需要时互相转换。例如 `Integer i = 1;` 会装箱，`int x = i;` 会拆箱。装箱会创建对象或从缓存取对象，拆箱会触发 `Integer.intValue()`，因此存在性能开销。

常见陷阱有两个：第一是空指针，`Integer i = null; int x = i;` 会触发 NPE；第二是比较陷阱，包装类型用 `==` 比较的是引用。`Integer` 在 -128 到 127 有缓存，超出范围比较时会得到“看似随机”的结果，因此要使用 `equals`。

### 1.3 访问控制
访问控制修饰符决定可见范围：`public` 任何地方可见；`protected` 同包可见且对子类可见；默认（package-private）仅同包可见；`private` 仅类内可见。顶层类只能是 `public` 或默认。

合理使用访问控制的目的不是“隐藏”，而是“约束依赖”。把最小必要的成员暴露出去，可以减少耦合，让类的内部实现可自由演化，同时也提高可测试性与可维护性。

### 1.4 继承与组合
继承表达“is-a”关系，组合表达“has-a”。组合通过持有对象并委托调用来复用行为，依赖更弱、变化成本更低。继承的问题是脆弱基类（基类变更导致子类行为改变）和层级膨胀，一旦继承层次被错误建模，后续扩展很难收敛。

实际项目中，优先使用接口 + 组合。当你需要复用实现细节且关系稳定时，再考虑继承。比如实现可插拔的缓存策略，用组合把策略对象注入进去，远比继承多个缓存基类更稳健。

### 1.5 抽象类与接口
抽象类适合“有部分实现且需要共享状态”的场景，可以有构造器和成员变量，且只能单继承。接口更强调“能力/契约”，允许多实现，并可用 `default` 方法提供兼容性实现，但接口不适合存放可变状态。

选型时可以问自己两个问题：是否需要共享字段或模板流程？是否需要多个类型组合？如果需要共享状态和模板流程，用抽象类；如果更强调能力扩展和多继承，用接口。

### 1.6 多态与动态绑定
多态指运行期根据对象实际类型选择调用哪个重写方法，动态绑定是其实现机制。Java对“重写”进行运行期分派，对“重载”在编译期完成静态分派。静态方法和字段不参与多态，容易导致“看似覆盖却未生效”的误解。

多态带来替换能力，但也有陷阱。例如在构造器中调用可被重写的方法，可能在子类尚未初始化时执行子类逻辑，导致空指针或状态不一致。

## 面试点与参考回答

### Q1 解释值传递与引用传递在Java中的真实含义
Java只有值传递。对基本类型，传的是值；对对象，传的是“引用的值”。因此在方法里重新给参数赋值不会影响外部变量，但对对象内部做的修改会反映到调用方。用一句话概括：传的是引用的拷贝，而不是对象的拷贝。

### Q2 什么时候选择抽象类，什么时候选择接口
抽象类用于共享状态或模板流程，适合有稳定层次结构且需要复用实现细节的场景。接口用于定义能力或契约，强调多实现与解耦，适合“可插拔能力”的扩展点。若二者都可用，优先接口 + 组合，抽象类作为共享实现的最后手段。

### Q3 组合优于继承的理由与实际例子
组合降低耦合并提升可替换性，避免继承层级带来的脆弱基类问题。实际例子是缓存策略：接口定义 `CachePolicy`，不同实现通过组合注入，而不是继承多个 `AbstractCache`。这样可以在不改动调用方的情况下替换策略。

### Q4 equals 和 == 的区别
`==` 比较的是引用是否相同或基本类型值是否相等；`equals` 用于逻辑相等，默认实现等同于 `==`。在需要“内容相等”时必须重写 `equals` 并保持与 `hashCode` 一致，否则会破坏集合行为。

## 掌握评估

### 自测1 能用简单代码示例解释装箱比较问题
写出 `Integer a = 100; Integer b = 100;` 和 `Integer c = 200; Integer d = 200;` 的比较结果，并解释缓存区间导致的差异，再补充 `equals` 的正确用法。

### 自测2 能画出类图并说明继承与组合的取舍
选择一个常见场景（如支付方式或日志策略），分别用继承与组合建模，说明哪种方式在扩展新类型时修改成本更低、测试更容易。

### 自测3 能清晰回答多态与方法分派规则
区分重写与重载的分派时机，补充静态方法、字段、构造器在分派上的特殊性，并解释为什么构造器中不建议调用可重写方法。
