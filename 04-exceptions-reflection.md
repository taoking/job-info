# 4. 异常体系与反射

## 知识点详解

### 4.1 异常类型：Checked与Unchecked
Checked异常用于可恢复、需要调用方处理的场景，例如文件不存在或网络抖动。Unchecked异常更多表示编程错误或不可恢复问题，例如空指针、数组越界。设计上应避免“到处 throws Exception”，否则异常处理会成为形式化负担。

在业务层可用自定义运行时异常统一封装错误码与上下文信息，底层Checked异常则在边界层转换为业务异常，保证调用方不会被迫处理无意义的技术细节。

### 4.2 try-with-resources
`try-with-resources` 依赖 `AutoCloseable`，能在正常或异常情况下自动关闭资源，并保留“主异常”，把关闭时异常放入 suppressed 列表。它比 `finally` 更简洁且更安全，避免因忘记关闭资源导致的泄漏。

### 4.3 反射与注解
反射通过 `Class` 元数据在运行期访问字段、方法和构造器，适合框架做依赖注入、AOP、序列化等。代价是性能较低、可读性差，并且可能破坏封装。实际应用应尽量缓存反射结果，或改用 MethodHandle/字节码增强提高性能。

## 面试点与参考回答

### Q1 什么时候用Checked异常
当调用方能够并且应该处理问题、且问题通常可恢复时使用Checked异常，例如文件读写、网络调用。若异常是编程错误或无法恢复，应使用Unchecked异常，以避免冗余的样板代码。

### Q2 try-with-resources与finally的区别
`try-with-resources` 自动调用 `close()` 并在异常时保留主异常，关闭异常作为 suppressed，语义更清晰；`finally` 需要手写关闭逻辑，容易遗漏或在异常覆盖时丢失原始异常。

### Q3 反射在框架中的用途与性能影响
反射用于运行期发现类与方法，实现注解驱动、IoC注入和动态代理。性能上反射调用比直接调用慢，通常通过缓存元数据、预热或字节码增强来降低开销。

## 掌握评估

### 自测1 能清晰解释异常分层设计
从“基础设施异常 -> 领域异常 -> 接口错误码”角度，说明在哪一层抛出、在哪一层转换，以及如何保留上下文信息。

### 自测2 能说明反射在Spring中的应用
结合Spring的注解扫描、依赖注入、代理生成，解释反射在“发现->实例化->注入”过程中的角色，以及如何避免反射的性能问题。
