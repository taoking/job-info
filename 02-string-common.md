# 2. String与常用类

## 知识点详解

### 2.1 String不可变性
String底层使用 `final` 字段持有字符数组（JDK9起为 `byte[]` + 编码标记），对象一旦创建就不可变。不可变性带来的好处包括：线程安全、可缓存hash值、字符串常量池复用、提升安全性（例如URL或文件路径不会在校验后被篡改）。

代价是频繁拼接会创建大量临时对象，带来GC压力。解决办法是使用 `StringBuilder` 或在编译期由编译器做优化，但循环拼接仍需手动优化。

### 2.2 StringBuilder与StringBuffer
`StringBuilder` 非线程安全但性能更好，适合单线程或线程内局部使用。`StringBuffer` 方法同步，适合多线程共享同一个可变字符串的场景，但现代代码中更常用 `StringBuilder` + 外部同步。

实际选择原则是“谁来保证线程安全”：如果对象只在本线程使用，用 `StringBuilder`；如果多个线程共享同一实例，要么用 `StringBuffer`，要么用 `StringBuilder` 并显式加锁。

### 2.3 intern机制
`String.intern()` 会返回常量池中的规范化字符串引用。如果常量池中已存在等值字符串，直接返回；否则将该字符串加入常量池。JDK7之后常量池在堆中，intern不会像PermGen那样容易溢出，但大量动态intern仍会增加堆占用和GC压力。

适用场景是“重复字符串多且可控”的系统，例如枚举值、状态码、协议字段等。对于用户输入或高基数数据，不建议盲目intern。

### 2.4 Object方法
`equals` 用于逻辑相等判断，需遵守对称性、传递性和一致性；`hashCode` 需要与 `equals` 保持契约，否则在哈希集合中行为异常。`toString` 应提供调试友好的信息。`clone` 是浅拷贝且依赖 `Cloneable` 标记，容易出错，实际更推荐拷贝构造器或工厂方法。

`finalize` 在新版本中已被废弃，不应作为资源释放手段，资源管理应使用 `try-with-resources`。

## 面试点与参考回答

### Q1 String为什么不可变，带来哪些优缺点
不可变保证线程安全、可缓存hash、支持常量池复用并增强安全性，但缺点是频繁拼接会产生大量临时对象，造成性能和GC开销。优化方式是使用 `StringBuilder`、避免无意义的临时拼接、或改为基于字符缓冲的写入方式。

### Q2 StringBuilder与StringBuffer的选择场景
单线程或线程内局部变量用 `StringBuilder` 性能更好；多线程共享同一个可变字符串实例时，用 `StringBuffer` 或显式同步保护 `StringBuilder`。总体上更推荐在调用方控制线程安全，而不是依赖 `StringBuffer` 的粗粒度同步。

### Q3 intern可能带来的内存问题
大量或高基数字符串做intern会把字符串留在常量池中，导致堆占用增加，GC压力变大，甚至引发 OOM。只有在字符串重复度高且集合规模可控时才值得intern。

## 掌握评估

### 自测1 能解释字符串拼接性能差异
写出循环拼接字符串的示例，比较 `+`、`StringBuilder`、`StringBuffer` 的性能差异，并说明编译器对常量拼接的优化边界。

### 自测2 能描述常量池行为与优化点
用 `new String("a")` 与字面量 `"a"` 对比说明常量池复用机制，解释 `intern()` 何时返回已有引用，何时新增。
