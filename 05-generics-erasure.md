# 5. 泛型与类型擦除

## 知识点详解

### 5.1 类型擦除
Java泛型在编译期生效，运行期通过类型擦除保留原始类型。编译器会在需要时插入强制类型转换，并通过桥接方法保持多态一致性。类型擦除的结果是：运行期无法获知真实泛型参数，因此不能在运行期做 `instanceof T` 或直接创建 `new T()`。

这既保证了与旧版本字节码的兼容性，也带来了限制。常见解决方式是显式传入 `Class<T>` 或使用“类型令牌”模式，通过反射保存泛型参数信息。

### 5.2 泛型通配符
`? extends T` 表示上界通配符，允许读取为 `T`，但不允许安全写入；`? super T` 表示下界通配符，允许写入 `T`，但读取只能当作 `Object`。这就是 PECS 原则：Producer Extends, Consumer Super。

理解通配符的关键在于“读写角色”。当容器是生产者时用 `extends`，当容器是消费者时用 `super`，当既读又写时避免使用通配符或使用具体类型。

### 5.3 泛型方法
泛型方法在方法层面声明类型参数，可通过类型推断简化调用。泛型方法常用于工具类或工厂方法，例如 `Collections.emptyList()`。合理使用可提升复用性，但过度泛型会降低可读性。

## 面试点与参考回答

### Q1 泛型如何在编译期保证类型安全
编译器会在泛型使用处进行类型检查，并在字节码中插入必要的类型转换，确保类型不匹配时编译失败而不是运行期报错。运行期看不到泛型参数，但编译期约束足以保证类型安全。

### Q2 为什么不能直接 new T()
由于类型擦除，运行期不知道 T 的具体类型，无法实例化。解决方法是传入 `Class<T>`，或使用工厂方法、反射以及 `Supplier<T>` 等方式来创建对象。

## 掌握评估

### 自测1 能用PECS原则解释通配符使用
准备一个“读多写少”的集合示例和一个“写多读少”的集合示例，分别用 `? extends` 与 `? super` 完成，说明为何这样选择。

### 自测2 能解释类型擦除导致的限制
列举不能创建泛型数组、不能 `instanceof T`、不能 `new T()` 的原因，并给出对应替代方案。
